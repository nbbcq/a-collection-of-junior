## 从 FS 到 BtrFS：文件系统的过去、现在以及未来

一份简短的类 Unix 文件系统发展历史。

什么是文件系统？简单地说，它是一种存储和组织计算机数据的方法，使得对数据的访问和查找变得更加容易。它使用文件和树形目录的抽象逻辑概念，隐藏不同硬件设备的细节，为内核提供统一的 IO 操作接口。

文件系统的种类有很多，磁盘文件系统、光盘文件系统、闪存文件系统、内存文件系统、网络文件系统、伪文件系统等等，但这里只谈一谈磁盘文件系统。

说道操作系统的历史，总少不了类 Unix 系统。文件管理作为操作系统的一项重要功能，必然与其相伴相随。它的文件系统发展历程称得上是文件系统发展史上的一个缩影。这个时间轴简要地展示了其发展历程。

在窥视文件系统的发展历程之前，先了解一下什么是 VFS。

## VFS 架构

VFS 即 Virtual file system，这张图很形象地描绘了什么是 VFS，只不过线条有点乱。抽象起来，便是这张图。

它并不是一个具体的文件系统，而是操作系统的文件系统虚拟层，在它的下面是实体的文件系统。

VFS 这一层对不同的文件系统系统抽象，为上层应用提供同一的接口，即：

* 相同的文件描述符
* 统一的文件操作

能够让上层的软件，使用单一的方式，来跟底层不同的文件系统沟通。也因为这个特性，类 Unix 系统能够很快地支持新的文件系统。

## 开始：System V FS（S5FS）（c. 1974）

第一代文件系统是 System V 的文件系统，它是第一个 Unix 文件系统，简称 FS

它对硬件设备进行了抽象，创造了 `superblock / inode` ，这点被以后的文件系统所继承。

这张图大家肯定不陌生，操作系统课程中对它有过了解，如果一个词来形如它：简单，简单得不能再简单，没有任何复杂的原理，结构一目了然。

同时速度也非常非常地慢，带宽利用率只有 2-5%。

慢？为什么慢呢？

一方面，在空间与速度的较量中，它选择了空间，块大小只有 512-1024 字节。

这里有个结论：块越大，速度越快。可是 Unix 系统中包含了太多的小文件，加之没有分片机制，大块必然会带来大量空间的浪费。

另一方面，磁盘并不是随机存储介质，FS 没有考虑磁盘的寻址时间。尽管文件的组织形式看起来一目了然，但在实际的存储中，目录会放得乱七八糟，文件也放得乱七八糟。比如 word 这个文本文件，放在 /home/user/workspace/a/b/c 目录下，我们要先在跟目录下找到 home 的 inode，再从 inode 中找到 block，再去 block 中找 usr……一次次重复这个操作，至少需要 20 多次磁盘访问，如果这些 block 随机分布，所需的时间就很恐怖了。

可以看到，是不合理的块大小以及文件的随机存放导致磁盘读写速度很慢。为了改进文件系统的吞吐量，伯克利设计了下一代 Unix 文件系统。

## Berkeley Fast File Systm（FFS or UFS）(c. 1984)

它利用了计算机的局部性原理，将磁盘划分为多个柱面组，确保数据与 inode 在相同的组中、同一文件夹下的文件及其信息尽可能地放在同一组、大文件的块组织尽可能的连续。同时，规定最小的块大小为 4 KB。

这些措施使它获得了更好的性能：14% - 17% 的带宽利用率。可分片的设计也节省了大约 45% 的空间。

与先前的文件系统相比，还有一点巨大的不同，它增加了文件一致性检查工具 fsck（file system check）。原先，系统掉电或磁盘发生问题后文件并不好恢复，fsck 的添加使文件系统的一致性检查和维护更容易。

此后的若干年间，FFS 不断改进，不久添加了日志功能，九十年代初期改进了块分配与预读取策略，文件系统的效率不断改进。

这一切看起来很美好...可事情往往不会发展得那么顺利。

## 担心

从这张表中可以看到，过去的十年间 CPU 的速度飞速增长，磁盘的吞吐量增长得却十分缓慢，有趋势表明磁盘的速度将会成为越来越多程序的瓶颈。

有部分人还作出了这种假设：主存容量不断增长，文件缓存于主存中，会使文件的读取速度越来越块，此时文件的写入却成为了瓶颈。

同时目前的文件系统存在两个问题：

1. 写入小文件的时候，少于 5% 的带宽被使用，时间都浪费在寻道上了；
2. 同步写入时，应用必须等待写入完成后才可以继续执行，而不是在后台继续执行其他操作。

基于以上三种考虑，一种新的文件系统被设计了出来——

## Log-structured File System（LFS）(c. 1991)

它的特点很明显：使用日志的方式记录数据，日志就是文件系统，文件系统就是日志。LFS 中数据与元数据的修改都是追加到日志末尾，没有原地更新，这种方法能够将磁盘的随机写转化成顺序写，重复利用写带宽。

带来的好处也很明显：写入的时候有 70% 的带宽利用率，要知道典型的 UFS 只有 5-10% 的利用率；损坏文件的恢复变得很容易，只要回滚到上一个正确的日志纪录点便可。

坏处呢？为了操作更有效率，LFS 需要大量的空闲空间来写入新的数据，这点对 LFS 来说真的是一个很大的挑战。

遗憾的是，历史证明了一切，这文件系统目前不怎么流行。

## ext2 and ext3 & ext4（c. 1993 - present）

Linux 下的原生文件系统是 ext 系列。它起源于教学系统 Minix，因为它的缺陷，发展了 ext2。ext2 无疑很成功，在性能测试中往往表现最佳。

随着磁盘容量的增大，文件的一致性检查令人头疼，因此在 ext2 的基础上添加了日志，升级为 ext3。

近年来 ext2/3 暴露除了一些扩展性问题，于是便催生了目前在使用的 ext4 文件系统。

## Write Anywhere File Layout(WAFL)(c. 1994)

WAFL 算不上是一个文件系统，它是一种文件布局，用于支持大型、高性能的 RAID 阵列，在崩溃或电源故障时不进行长时间一致性检查的快速重新启动，以及适应快速增长的文件系统大小。

它带来了几项很新颖的设计：

* Copy-on-Write，写时复制。

  总的来说，COW 只复制引用而避免复制数据；当的确需要进行写入操作时，如图中所描述的那样，首先进行数据拷贝，再对拷贝后的数据执行写入操作，之后再更新各个父节点的信息。

  这样，便无需担心意外断电等突发情况导致的文件一致性错误。

* 元信息存储在文件中。

  它允许在硬盘上的任何地方写入元数据块，使文件系统的增长变得十分容易。

## SGI's XFS（c. 1996）

在 XFS 文件系统中，引入了逻辑卷管理员功能(LVM，Logical Volume Manager)。

想象一个情况，在当初规划主机的时候只分配给一个逻辑磁盘 50G 的空间，等到若干月后，发现它不够大，此时你能怎么做？大多数人会选择重新分区、格式化、拷贝原始的数据。这太繁琐了，而且如果第二次分区给的容量太多，会导致很多磁盘容量的浪费。若将这个逻辑盘缩小，又要重复上述流程。这太繁琐、耗时了。

为了解决这个问题，引入了 LVM 这个东西，它的重点在于“可以弹性地调整文件系统的容量”。LVM 可以整合多个逻辑分区在一起，让这些分区看起来就像是一个磁盘一样，而且还可以在未来新增或移除其他的分区到这个 LVM 管理的磁盘当中。

它还采用了 B+ 树组织文件结构，优化了多线程的读写，采用动态 inode 分配策略，拥有了 90 - 95% 的带宽利用率。

此后的几年间，文件系统不断改进，先后出现了 Veritas File System(VxFS) 、 Reiserfs v. 1 - 4 (c. 1998 - present) 、 JFS (c. 2000)，直到 2004 年...

## Zettabyte File System (ZFS) (c. 2004)

 ZFS 是一个革命性的文件系统，为传统的磁盘设计，号称最后一个文件系统。

它除了是第一个128位的文件系统，能存储1800亿亿（18.4 × 1018）倍于当前64位文件系统的数据外，
它从根本上改变了文件系统的管理方式，全面抛弃传统 File System + Volume Manager + Storage的架构，所有的存储设备是通过 ZFS Pool 进行管理，只要把各种存储设备加 入同一个ZFS Pool，就可以轻松的在这个 ZFS Pool 管理配置文件系统。提供了优异的拓展性。

它继承并改进了 WAFL ，基于事物的操作，完全保证了数据的正确和完整，再也不需要 fsck 等一致性检查、修复工具了。

可变大小的数据块、智能预读取等特性保证了速度。

此外，在安全、配额、预留、镜像等方面提供了许多企业级别的超强功能。

## Btrfs （c. 2009）

ZFS 的确带来了很多崭新的观念，对文件系统来讲是一个划时代的作品。因其开源许可证的原因，它并不能被整合到 Linux 内核中。Linux 社区开发了 Btrfs，比较 Btrfs 的特性，将会发现 Btrfs 和 ZFS 非常类似。也许我们可以认为 Btrfs 就是 Linux 社区对 ZFS 所作出的回应。从此往后在 Linux 中也终于有了一个可以和 ZFS 相媲美的文件系统了。

它是目前少数专门对 SSD 进行优化的文件系统。

## 总结

回首类 Unix 文件系统的发展史，简单来说，文件系统的设计大多集中于吞吐率、一致性、扩展性三个方面。

在空闲块的分配上，不断优化块分配策略，由块簇到区段再到可变块。

对于索引方式，由链表换成表格，再到 B 树。

也不段改进文件系统的一致性，先后出现了文件系统一致性检查工具 fsck、日志、写时更新策略等。

元信息组织的不断改进，以及卷管理、存储池概念的引入大大改善了文件系统的拓展性。

近些年来，固态硬盘发展迅速，传统的磁盘文件系统并不能很好地发挥固态硬盘的特性。2016年的 WWDC 大会上，Apple 公布了一个名为 APFS（Apple File System）的文件系统，专为闪存和固态存储设备优化。可以预见，未来越来越多的文件系统会针对固态硬盘进行优化，亦专门设计...

总而言之，文件系统已经很成熟了吗？我看未必，新存储方式的流行、旧方式的淘汰，必将催生出一批新的文件系统。